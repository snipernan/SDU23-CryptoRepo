# Project22: research report on MPT

## MPT概述

Merkle Patricia树(MPT)是以太坊用于存储状态和生成交易根哈希的关键的数据结构。它融合了Merkle树和Trie树的优点,可以高效地存储和查找键值对,生成数据的哈希标识,并支持快速状态回滚等功能。MPT对于树中节点的插入、查找、删除操作,时间复杂度可以达到对数级O(logN),因此它是一种相对高效的存储结构。
![enter image description here](https://pic1.zhimg.com/70/v2-f2bf532635c2234b190ea88fbd7a3475_1440w.avis?source=172ae18b&biz_tag=Post)

## MPT树的组成

### 节点类型

MPT树由四种类型的节点组成:

 - 空节点,表示为空字符串,在代码中用空字符串表示。

 - 叶子节点,是一个包含两个元素的数组,格式为[encodedPath, value]。其中encodedPath表示当前节点路径的十六进制前缀编码,value表示从根节点到当前节点路径组成的键对应的值。叶子节点保存了实际的数据。

 - 分支节点,是一个包含17个元素的数组,格式为[v0,...,v15,vt]。其中v0~v15表示子节点数据的哈希值,如果没有子节点则为空;vt表示从根节点到父节点路径组成的键对应的value值。

 - 扩展节点,是一个包含两个元素的数组,格式为[encodedPath, hash]。其中encodedPath表示当前节点路径的十六进制前缀编码,hash表示当前节点子节点数据的哈希值。扩展节点通过哈希指向子节点。

### 键编码

MPT树使用了三种键编码方式:

 - Raw编码:原始的字符编码,是MPT树对外接口默认使用的编码方式。

 - Hex编码:每个字节用两个十六进制数字表示,可以避免键值中出现特殊控制字符。

 - HP编码:在Hex编码的基础上加上前缀,用于区分叶子节点和扩展节点。根据奇偶性添加不同前缀。

### 节点存储

每个MPT节点使用NodeFlag结构存储哈希值、脏标记等元数据。节点的数据用RLP编码后和节点哈希以<hash, rlp_encoded_data>的形式保存在LevelDB数据库中。通过根节点的哈希值可以重新构造出整棵树。


好的,已对第三、四、五部分进行进一步扩充:

## MPT树的工作机制

### (一)树的构建

从一个空节点开始,逐步插入键值对,使用不同类型的节点构建MPT树。首先判断键是否有公共前缀,有则共享前缀路径;如果有分支则新建分支节点,没有分支则新建叶子节点。一个键插入后可能会创建多个扩展节点和一个叶子节点。

### (二)键的查找

从根节点开始,使用编码后的键逐级向下查询,直到匹配到叶子节点。查询过程利用缓存的哈希值避免重复计算,可以大幅加速查找过程。具有相同前缀的键由共同的扩展节点共享路径,查询性能很高。

### (三)树的更新

插入或修改键值对时,会先查询找到相应的叶子节点,然后创建或更新该叶子节点。接着通过哈希递推的方式依次更新其父节点直到根节点的哈希值,完成数据更新。MPT树只需要更新路径上的相关节点。如果键不存在,还需要创建新的扩展节点和叶子节点。

### (四)树的持久化

使用&lt;hash, rlp_encoded_data&gt;格式持久化每个节点的数据。节点数据用RLP编码保证了可扩展性。持久化后,通过根节点的哈希就可以重新构造出原始的树状态。也可以按需从数据库加载特定节点,无需全量加载。

### (五)树的修剪 

内存中的MPT树会 saves最近访问和修改的节点,根据访问时间和修改标记对内存中的节点进行修剪,释放未被使用的节点占用的内存空间。修剪不会影响持久化的数据。

## 四、MPT树的应用

MPT树是以太坊存储世界状态的关键数据结构。世界状态包含所有账户的信息,以及每个账户存储的键值对。普通账户存储账户余额等,合约账户存储合约数据。MPT树的根哈希代表了整个世界状态,存储在区块头中。这样通过MPT树可以高效验证一个状态转换的正确性。


## 五、MPT树的优点

### (一)空间优化

MPT树通过将公共前缀提取到扩展节点中,避免存储大量的空分支节点和叶子节点,从而极大地节省了存储空间。与未优化的前缀树相比,MPT树能够将存储空间降低90%以上。同时,MPT树使用紧凑的RLP编码持久化节点数据,也大大压缩了存储需求。总体来说,MPT树空间优化主要得益于公共前缀提取、节点优化以及高效编码持久化。这使得MPT树成为以太坊存储世界状态的理想选择。

### (二)快速查询

MPT树可以充分利用键值的共享前缀进行快速查询。相比遍历哈希表的O(n)复杂度,利用前缀查找,MPT树的查询时间复杂度可以降低到O(logn)。另外,MPT树还使用缓存机制存储最近访问的节点,避免重复计算哈希,进一步加速查询速度。总体来说,共享前缀压缩和缓存机制使MPT树具有非常高的查询性能。

### (三)高效更新  

在MPT树中更新键值对时,只需要更新相关的扩展节点和叶子节点,并重新计算其影响路径上的哈希即可,无需重新构建整棵树。因此相比重建一棵树,MPT树更新键值对的时间复杂度仅为O(logn)。这种局部更新的方式极大地提升了MPT树的更新效率。
![enter image description here](https://pic1.zhimg.com/80/v2-1acfb4f6da08977b33ee75e349f83d88_720w.webp)

### (四)可证明性  

MPT树可以通过提供从根节点到叶子节点的路径快速验证某个键值对是否存在,而无需遍历整棵树。这种可证明性非常适合区块链场景下快速验证交易存在性。与遍历整棵树相比,路径证明大幅减少了验证所需的计算量。

### (五)支持快照和回滚

通过根节点的哈希,MPT树可以在任意时刻进行快照,并快速回滚到指定快照状态。相比于重建整棵树,基于快照的回滚机制大大提高了状态恢复的效率。同时也便于并行计算不同状态快照的哈希。

## 参考文献
[1. 以太坊 Merkle Patricia Tree 全解析](https://zhuanlan.zhihu.com/p/46702178)

[2. 区块链中Merkle树性能研究](http://c-s-a.org.cn/html/2020/9/7528.html)


